;This program will send an uart frame and an output enable signal to drive a rs485 
;half duplex tranceiver, It then wait for a response for a setable period of time. 
;
;The first word represent the length of the frame decreased by one (max 0xffff)
;The second word represent the lime to wait for a response frame right after TX (max 0xffff, 0x0000 for not listening for response)
;For example:
;to send the frame 0x1234 and not wait for response , send:  
;     0x00000001 0x00000000 0x12 0x34         (len=2 -> 2-1=0x01)

;to send the frame 0x123456 and wait the maximum for response, send: 
;     0x00000002 0xffffffff 0x12 0x34 0x56   (len=3 -> 3-1=0x02)

.program rs485
.side_set 2 opt
    pull block              ; Read the first byte, indicating the number of bytes to read +1 ; This can't come from the DMA as in 8 bit mode it will repeate it to fill 32bits.
    mov x, osr              ; Store it in "x" 
    pull block              ; Read the second byte, indicating the delay to wait for a response frame
    mov isr, osr            ; Store it in ISR temporarly 
    nop        side 3 [3]   ; side 0b11 (oe=1 tx=1) IDLE a bit.. 
bytesloop:
    set y, 7   side 2 [3]
    pull       side 2 [3]   ; Start bit   side 0b10 (oe=1 tx=0)
bitsloop:
    out pins, 1       [3]   ; bit 0..7
    jmp y--, bitsloop [3]   ; next bit
    nop        side 3 [3]   ; Stop bit  side 0b11 (oe=1 tx=1)
    jmp x--, bytesloop [3]     ; next byte
endtx:
    nop        side 3 [3]   ; side 0b00 (oe=0 tx=0)

    ;jmp endtx ;TODO, generate an interupt to signal the end of transmission.

; RX part ____________________________________________________________________________________________
; For debuging the sampling with an oscilloscope, we can use the TX pin as a sampling indication (1 cycle pulse during sample) set side1/0 
    mov x, isr  ; Prepare timeout cpt for start of frame (prevoiously stored in ISR by reading byte 2)
    ; TODO reset ISR to 0?
waitforstart:
    jmp x--, notimeout 
    jmp timeout 
notimeout:
    jmp PIN waitforstart   ;side 1 for debug
    ;  We have the start condition!
    set x, 10     [2]  ; reset timeout value to detect the end of frame later (end of frame if no start bit for a short period of time)
    set y, 7                 ; prepare the bitloop iterator
rxbitloop:
    nop [2] ;wait for the eye
    nop [2]
    in pins, 1    ; Shift data bit into ISR    
    jmp y-- rxbitloop ; Loop 8 times, each loop iteration is 8 cycles
    push                ; send the byte to the fifo
    
    jmp waitforstart   ; 
timeout:
    nop side 1
    jmp timeout ;TODO, generate an interupt to signal the end of transmission (and eventually reception). TODO find a way to indicate end is detected to the CPU, pass the size of the buffer to read?
    ; ideas: push a fix amount of data with zeros (max frame length and then push the size)
    ; or maybe go to an interupt and read the DMA pointer if we can be sure the dma can not be late. We could wait for the fifo to be empty in the state machine?
    ; read more about the DMA and how we can control it from the PIO ?
    ; alternative would be to use a different PIO for managing the status of RX, TX; but I would prefer to have a maximum of rs485 in parallel
